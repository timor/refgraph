#+TITLE: Reference Graph Visualization

* Idea
- Goal: get overview over certain scientific field by taking advantage
  of the information that is usually provided by reference managers,
  in addition to information that is usually provided by task planning systems.
- extract information from bibtex files:
  - author-paper relation
  - number of citations per paper (custom field)
- combine with:
  - personal progress on papers
  - personal classification on papers
- several visualization modes
  1. Collaboration Graph
  2. Classification

* Usage
Load the page with the relevant data by dragging a BibTex file onto
the canvas.  The layout is responsive, and nodes can be dragged with
the mouse.  Dragging the background will pan the view, and mouse wheel
can be used to zoom.

Clicking a paper will try to open a pdf file with the same name in the
current directory.

Clicking an author will redirect to a Google Scholar search with that author.

Only tested on Firefox.

** Advanced
Using the browser's JS console, advanced functionality can be
accessed:

*classification view*: enter =change_mode('category')=.  To switch
back to the collaboration graph: =change_mode('collaboration')=

* Implementation
The application basically consists of one html file that includes the
necessary CSS and Javascript.

It depends on d3.js for the
visualization, and on md5.js and a modified version of jdenticon for
identicon generation.

The [[Parser]] responsible for extracting the information from the BibTex
files is generated using PEG.js.

#+BEGIN_SRC html :tangle refgraph.html :noweb tangle
  <!DOCTYPE html>
  <meta charset="utf-8">
  <style>

    <<css-definitions>>

  </style>
  <body>
    <script src="http://d3js.org/d3.v3.js"></script>
    <script src="scripts/jdenticon-1.3.2.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/blueimp-md5/2.3.0/js/md5.min.js"></script>
    <script src="scripts/parser.js"></script>
    <script>

      <<javascript-graph-functionality>>

    </script>
  </body>
#+END_SRC

** Styling
:PROPERTIES:
:noweb-ref: css-definitions
:END:

*** General CSS Classes

General page layout:

#+BEGIN_SRC css
  html, body { overflow: hidden }
  svg { position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 90%;
      }

  ,* {
      font-family: sans-serif;
  }
#+END_SRC

CSS Classes used:

- =.node= :: elements representing nodes (papers and authors)
- =.node_bg= :: the background of the node images (to allow image
     containing transparency to be more visible)
- =.node_bg_glow= :: the glowing background of nodes (used for visualizing state
     information)
- =.link= :: the lines representing the links between nodes
- =.<state-class>= :: contains the actual specification for each state
     of a paper
- =.author= :: author nodes
- =.paper= :: paper nodes

All text in the nodes should use sans serif fonts, and be
non-selectable, because that interferes with dragging.  The background
of paper nodes is created by applying a [[glow-filter][glow filter]] to the rectangle
behind.  Depending on the personal state of the paper, different
colors are chosen.  The background of author nodes is hidden

#+BEGIN_SRC css
  .node text {
      // pointer-events: none;
      font: 10px sans-serif;
      -webkit-user-select: none;  /* Chrome all / Safari all */
      -moz-user-select: none;     /* Firefox all */
      -ms-user-select: none;      /* IE 10+ */
      user-select: none;          /* Likely future */
  }

  .node_bg {
      fill: white;
      /* stroke-width: 1px; */
      /* stroke: black; */
  }

  .node_bg_glow.paper {
      opacity: 0.3;
      filter: url(#glow);
  }

  .node_bg_glow.paper.read {
      fill:green;
  }

  .node_bg_glow.paper.unread {
      fill:red;
  }

  .node_bg_glow.paper.started {
      fill:orange;
  }

  .node_bg_glow.paper.overview {
      fill:yellow;
  }

  .node_bg_glow.author {
      visibility: hidden;
  }

  .link {
      stroke: #ccc;
  }

  #+END_SRC

*** Circle-Packing CSS Classes

Specifically for the circle packing layout, which is currently used
for the Classification view:

- =.pack= :: elements inside the pack layout
- =.leaf= :: the leaf nodes of pack layout

All the circles in the pack layout are bluish, transparent and have a
thin border stroke.  The circles for the leaf nodes(the actual papers)
are not shown.

#+BEGIN_SRC css
  circle.pack {
      fill: rgb(31,119,180);
      fill-opacity: .25;
      stroke-width: 1px;
  }

  .leaf {
      visibility: hidden;
  }

  text.pack {
      font: 12px sans-serif;
      stroke: #fcc;
      fill: #fcc;
  }

#+END_SRC

*** Tooltip
The tooltip is styled here.
- =.tooltip_text= :: text of tooltips
- =.tooltip_bg= :: background (svg rect) of tooltips

#+BEGIN_SRC css
  .tooltip_text {
      font: 12px sans-serif;
  }

  .tooltip_bg{
      fill: white;
      stroke: black;
      stroke-width: 1;
      opacity: 0.85;
  }
#+END_SRC
** Code
:PROPERTIES:
:noweb-ref: javascript-graph-functionality
:END:

*** Global Variables
For lack of better programming style, the following information is
defined in global variables:

#+NAME: js-globals
#+BEGIN_SRC js
  var width = 1200,               // width of the svg (not used correctly)

      height = 900,               // height of the svg portion (not used correctly)

      icon_size = 16,             // base size of icons for nodes

      jdenticon_size = 50        // base size of the identicons, note
                                  // that jdenticon does not allow
                                  // images smaller than 30, and padding
                                  // is added to that, so 40 should be a
                                  // safe minimum

#+END_SRC

For the imported json data, globals are defined for the top-level
elements of that data (TODO link to json data layout)

#+NAME: data-globals
#+BEGIN_SRC js
  var nodes, links, tree;
#+END_SRC

Other globals are defined before their respective usage.

*** SVG DOM Structure
generally, d3.js functionality is used to generate the DOM structure.

The svg element should fill the whole width of the browser page, but
leave some space below for controls.  Also, pointer events have to be
caught explicitly.  These are actually later caught by the big background
rectangle (and I suppose bubbled to the svg element) to implement zooming and panning.

Note that the variable =svg= actually contains a =g= (group).

#+BEGIN_SRC js
  var svg = d3.select("body").append("svg")
  // .attr("width", width)
  // .attr("height", height)
      .attr("height", "100%")
      .attr("width", "100%")
  // .attr("viewBox","-0 -250 700 500")
      .attr("pointer-events", "all")
      .append("g")
  // .attr("id","g1")
      .call(d3.behavior.zoom().on('zoom', redraw))
  ;
#+END_SRC

There is a transparent background rectangle for catching mouse
events.  It is made as big as the screen to make sure that all
background is covered.

#+BEGIN_SRC js
  svg.append("rect")
      .attr("width", screen.width)
      .attr("height", screen.height)
      .style("fill", "none")
  ;
#+END_SRC

There is a container group for all interactive content.  This is also
the one that the zoom and pan transformations are performed upon:

#+BEGIN_SRC js
  var container = svg.append("g").attr("id","nodecontainer");
#+END_SRC

**** Tooltips

Tooltips appear when hovering over papers, showing the full title.

There is only one tooltip consisting of a rect and text which live in the top group,
and are placed as needed.

#+BEGIN_SRC js
  var tooltip = svg.append("rect")
      .attr("class","tooltip_bg")
      .attr("id","tooltip_bg")
      .attr("visibility", "hidden")
      .attr("rx", 4)
      .attr("ry", 4)
      .attr("height",16)
      .attr("width",52);

  var tooltip_text = svg.append("text")
      .attr("class","tooltip_text")
      .attr("visibility", "hidden");

  function show_tooltip(d) {
      if (d.type == "paper") {
          x = d3.event.clientX;
          y = d3.event.clientY;
          tooltip_text
              .text(d.labeltooltip)
              .attr("visibility","visible")
              .attr("x", x + 11)
              .attr("y", y + 27);
          tooltip
              .attr("visibility","visible")
              .attr("x", x + 8)
              .attr("y", y + 14)
              .attr("width", tooltip_text.node().getComputedTextLength()+8);
      }
  }

  function hide_tooltip(d) {
      tooltip.attr("visibility", "hidden")
      tooltip_text.attr("visibility", "hidden")
  }
#+END_SRC

The =show_tooltip= and =hide_tooltip= functions are later used as
onMouseover and onMouseout handlers when the actual nodes are created
(TODO: link)

**** Filter for Node Background<<glow-filter>>
The blur effect of the node background is created here.  The defs node
is attached directly to the =svg= DOM node.

#+BEGIN_SRC js
  var defs = d3.select("svg").append("defs");
  var filter = defs.append("filter")
      .attr("id", "glow");
  filter.append("feGaussianBlur")
      .attr("stdDeviation", "3.5")
      .attr("result", "coloredBlur");
#+END_SRC
*** Zooming
Zooming is provided as d3.js-provided behavior, with the following
being the zoom event handler.

#+NAME: redraw
#+BEGIN_SRC js
  function redraw() {
      container.attr("transform", "translate(" + d3.event.translate + ")scale(" + d3.event.scale +")");
      // svg.attr("transform", "translate(" + d3.event.translate + ")");
  };
#+END_SRC
*** Used Layouts
Several different d3.js layouts are used.  All of them are initialized
here.  For some reason it is important that the force layout is
created last.  Also, the initial mode is set to the collaboration
layout.

#+NAME: make_layout
#+BEGIN_SRC js
  function make_layout() {
  
      make_pack_layout();

      make_force_layout();

  }
#+END_SRC
**** Force Layout

The force layout is used to display the collaboration graph.
All the global properties are set when creating the initial =force=
object.  Interactive aspects of the layout are handled in
[[change_mode][=change_mode=]].

For different modes, different settings are used for the following
global variables:
#+BEGIN_SRC js
  var kx_mul = 0.15,              // multiplier for attractor force in x direction

      ky_mul = 0.4                // multiplier for attractor force in y direction
#+END_SRC

Gravity is turned off because all paper nodes have an attractor, so
the layout does face the danger of expanding indefinitely.  Charge
Distance is set, but it seems it does not have a notable influence on
performance.  It seems because charges are quite high, friction was
"increased" from the default 0.9 to 0.7 to stop high-speed movement.

#+NAME: force
#+BEGIN_SRC javascript
  var force = d3.layout.force()
      .gravity(0)
      .distance(50)
      .chargeDistance(700)
      .friction(0.7)
      .size([width, height]);
#+END_SRC

Here is the force layout initialization.  It must be called after data is
available.  See [[force-init]] for what actually happens, and [[force-tick]]
for the tick event handler that is attached.

#+NAME: make_force_layout :noweb tangle
#+BEGIN_SRC js
  function make_force_layout() {
      var link,                   // selection of created svg elements for link representation

          node                    // selection of created svg elements for node representation

      <<force-layout-initialization>>

      <<force-tick-handler>>
  }
#+END_SRC

***** Node Property Helper functions
Several node properties are data-dependent.  The following definitions
are used to calculate the relevant values for the layout.

****** Node Significance

Used as basis for other layout properties.

The significance of authors is determined by the balls they have, and
weighted using a fractional-exponent exponential function, to be able
to distinguish the less-significant authors better, since there are
usually more of them.

The significance of papers is the number of citations they have.  This
is weighted logarithmically for similar reasons.

#+NAME: node_significance
#+BEGIN_SRC javascript
  function node_significance(d) {
      if (d.type == "author")
          // return icon_size * (1 + (d.balls/20);
          return (1 + (Math.pow((d.balls-1), 0.8) * 0.5));
      else
          return (1 + Math.log10(1 + d.citations));
  }
#+END_SRC

****** Node Image Positioning
The node image size depends on the significance.

#+NAME: node_image_size
#+BEGIN_SRC javascript
  function node_image_size(d) {
      return icon_size * node_significance(d);
  };
#+END_SRC

Used to center the image for a node.
#+NAME: node_image_offset
#+BEGIN_SRC javascript
  function node_image_offset(d) {
      return - (node_image_size(d) / 2);
  }
#+END_SRC

****** Node Charge
For the collaboration layout, the node charge is made dependent on the
node significance.  This way, it is easier to place lesser-significant
nodes around the more central nodes.

#+NAME: collab_charge
#+BEGIN_SRC javascript
  function collab_charge(d) {
      return (node_significance(d) * -300);
  }
#+END_SRC

***** Node Dragging Behaviour
Dragging is provided by a d3.js behavior, but the default event
handlers are not used.

#+BEGIN_SRC js
  var drag = d3.behavior.drag()
      .origin(function(d) { return d; })
      .on("dragstart", dragstarted)
      .on("drag", dragged)
      .on("dragend", dragended);
#+END_SRC

Instead, the following handlers are implemented.  Note that they rely
on undocumented internals (the meaning of the individual bits of the
=fixed= property).  These are copied from the original functions.

#+NAME: dragstarted
#+BEGIN_SRC js
  function dragstarted(d) {
      d3.event.sourceEvent.stopPropagation();
      d3.select(this).classed("dragging", true);
      // force.d3_layout_forceDragstart(d);
      d.fixed |= 2; // set bit 2
  }
#+END_SRC

#+NAME: dragged
#+BEGIN_SRC js
  function dragged(d) {
      // d3.select(this).attr("cx", d.x = d3.event.x).attr("cy", d.y = d3.event.y);
      // d.x = d3.event.x, d.y = d3.event.y;
      d.px = d3.event.x, d.py = d3.event.y;
      force.resume(); // restart annealing
  }
#+END_SRC

#+NAME: dragended
#+BEGIN_SRC js
  function dragended(d) {
      d3.select(this).classed("dragging", false);
      // force.d3_layout_forceDragend(d);
      d.fixed &= ~6; // unset bits 2 and 3
  }
#+END_SRC

***** Force Layout Initialization <<force-init>>
:PROPERTIES:
:noweb-ref: force-layout-initialization
:END:

****** Connecting Layout to Data
Feed the force layout with the actual data.  d3.js expects a certain
data layout, from which it initializes connectivity and node
properties (TODO: link)
#+BEGIN_SRC js
  force
      .nodes(nodes)
      .links(links)
  ;
#+END_SRC

****** Creating the SVG elements

d3.js's enter selection mechanism is used to get the actually created
svg DOM nodes for the links (lines) and the nodes (groups).

#+BEGIN_SRC js
  link = container.selectAll(".link")
      .data(links)
      .enter().append("line")
      .attr("class", "link");

  node = container.selectAll(".node")
      .data(nodes)
      .enter().append("g")
      .attr("class", "node")
      .on("mouseover", show_tooltip)
      .on("mouseout", hide_tooltip)
      .call(drag);
#+END_SRC

****** Node Background

The background rectangles are attached.  These are connected to the
[[glow-filter]] using [[Styling][CSS]].  A class is added with the same name as the
personal reading state indicated in the data.

#+BEGIN_SRC js
  node.append("rect")
      .attr("x", node_image_offset)
      .attr("y", node_image_offset)
      .attr("width", node_image_size)        
      .attr("height", node_image_size)
      .attr("class", function(d) {
          var s= "node_bg_glow " + d.type;
          if (d.type == "paper") s = s + " " + d.state;
          return s;
      });
#+END_SRC
****** Node Images

The nodes themselves are represented by images.  Depending on the node
type, different images are loaded.
******* Author Nodes

#+BEGIN_SRC js
  node.filter(function(n) {return n.type == "author"})
      .append("image")
      .attr("xlink:href", "graph-assets/user.png")
      .attr("x", node_image_offset)
      .attr("y", node_image_offset)
      .attr("width", node_image_size)        
      .attr("height", node_image_size);
#+END_SRC

******* Paper Nodes

For papers that have already been started reading, show an identicon.
Otherwise, an empty placeholder.  This should make it easier to
recognize papers by their identicon over time, also visualizing where
there are still "gaps" in the research.

A small symbol represents the publication type, e.g. conference paper,
journal paper, PhD Thesis, etc.  For now, only one symbol is used,
though.  This symbol shall eventually be made optional, since it
crowds the whole layout quite a bit.  Also, this symbol is hidden by
default. See [[Controls]].

In order to make distinguishing the papers easier, md5 and jdenticon
are used to calculate hash values of the bibtex key.  The hash is
stored in the DOM attribute =data-jdenticon-hash=.  This is a
non-standard attribute so far, and is accessed by the modified
jdenticon code.

The identicon gets a white background, to make it easier to
distinguish visually.

#+BEGIN_SRC js
  node.filter(function(n) { return n.type == "paper"})
      .append("circle")
      // .attr("x", node_image_offset)
      // .attr("y", node_image_offset)
      // .attr("width", node_image_size)
      // .attr("height", node_image_size)
      .attr("r", function(d) {return node_image_size(d) / 2.2})
      .attr("class", "node_bg");

  node.filter(function(n) { return (n.type == "paper" && n.state != "unread")})
      .append("g")
      .attr("class", "jdenticon")
      .attr("data-width", jdenticon_size)
      .attr("data-height", jdenticon_size)
      .attr("data-jdenticon-hash", function(d) { return md5(d.name)})
      .attr("transform", function(d) { return "scale(" + node_significance(d) * (icon_size / jdenticon_size)  + ")"; });


  node.filter(function(n) { return n.type == "paper"})
      .append("image")
      .attr("xlink:href", "graph-assets/note.svg")
      .attr("class", "pub_type")
      .attr("x", node_image_offset)
      .attr("y", node_image_offset)
      .attr("width", function(d) {return node_image_size(d) / 2.5})
      .attr("height", function(d) {return node_image_size(d) / 2.5})
      .attr("visibility", "hidden");
#+END_SRC

****** Author Hyperlinks
The Author nodes are clickable, and link to a scholar search with the
author's name.

#+BEGIN_SRC js
  node.append("g")
      .append("a")
      .attr("xlink:href",function(d) {
          if (d.type == "author")
              return "http://scholar.google.com/scholar?q=" + encodeURIComponent(d.name)
          else
              return d.name+".pdf"})
      .append("text")
      .attr("dx", 12)
      .attr("dy", 16)
      .attr("text-anchor", "middle")
      .text(function(d) { return d.name });
#+END_SRC
****** Initial Node Positions
To help converging, the layout is initialized by setting all the nodes
with attractor targets to their calculated target positions.

#+BEGIN_SRC js
  nodes.forEach(function(node) {
      if (node.x_target) node.x = node.x_target;
      if (node.y_target) node.y = node.y_target;
  });
#+END_SRC
****** Initial Author Positions
The initial positions of the author nodes are set to the positions of
the paper nodes.  This is intended to allow the layout to converge
faster, but does not work well.  When the layout starts, the first few
cycles exhibit very high fluctuation amplitudes. (TODO: check if this
is better after reordering)

#+BEGIN_SRC js
  // source: author, target: paper
  links.forEach(function(link) {
      var a_index = link.source;
      var p_index = link.target;
      nodes[a_index].x = nodes[p_index].x;
      nodes[a_index].y = nodes[p_index].y;
  });

#+END_SRC
***** Force Layout Tick Handler<<force-tick>>
:PROPERTIES:
:noweb-ref: force-tick-handler
:END:
This is the "hot loop" that actually updates all the svg elements
according to the internal simulation.  It implements the attraction
forces and updates the position of the svg nodes as well as their
links.

#+BEGIN_SRC js
  force.on("tick", function(e) {
      var kx = e.alpha * kx_mul;
      var ky = e.alpha * ky_mul;

      nodes.forEach(function(node) {
          if (node.x_target)
              node.x += (node.x_target - node.x) * kx;
          if (node.y_target)
              node.y += (node.y_target - node.y) * ky;
      });

      link.attr("x1", function(d) { return d.source.x; })
          .attr("y1", function(d) { return d.source.y; })
          .attr("x2", function(d) { return d.target.x; })
          .attr("y2", function(d) { return d.target.y; });

      node.attr("transform", function(d) { return "translate(" + d.x + "," + d.y + ")"; });
  });
#+END_SRC
**** Circle Packing Layout
The circle packing layout is currently used for the classification
view.

The node value for this layout is a constant, resulting in
evenly-sized leaf nodes (papers), which themselves are not actually
displayed but only used as an attraction center point.
(see [[Styling]])

#+BEGIN_SRC js
  var pack = d3.layout.pack()
      .size([width , width])
      .value(function(d) { return 50; });
#+END_SRC


#+NAME: make_pack_layout
#+BEGIN_SRC js
  function make_pack_layout() {
      <<pack-layout-initialization>>
  }
#+END_SRC
***** Pack Layout Initialization <<pack-init>>
:PROPERTIES:
:noweb-ref: pack-layout-initialization
:END:

The Layout itself is created after data has been loaded by creating a
svg group element for it (initially invisible).

#+BEGIN_SRC js
  pack_svg = container.append("g")
      .attr("id", "pack_svg")
      .attr("opacity",0);
#+END_SRC

=tnode= holds the actually created svg elements, using d3.js's enter
selection mechanism.  If a node has no children, it is assigned the
=leaf= class.  Also, the positions are already assigned here.  The
actual representation is a =circle= element.

#+BEGIN_SRC js
  var tnode = pack_svg.datum(tree).selectAll(".tnode")
      .data(pack.nodes)
      .enter().append("g")
      .attr("class", function(d) { return d.children ? "tnode" : "leaf tnode"; })
      .attr("transform", function(d) { return "translate(" + d.x + "," + d.y + ")"; });

  tnode.append("title")
      .attr("class", "pack")
      .text(function(d) {return d.name});

  tnode.append("circle")
      .attr("class", "pack")
      .attr("r", function(d) {return d.r});
#+END_SRC


Labels for the categories are created, and moved a bit up from the
center to increase readability.  The name is be clipped if it is too
long.

#+BEGIN_SRC js
  tnode.filter(function(d) { return d.children; }).append("g")
      .attr("transform", function(d) { return "translate(0," + (-d.r/10) + ")scale(" + Math.sqrt(d.r/50) + ")";})
      .append("text")
      .attr("class", "pack")
      .style("text-anchor", "middle")
      .text(function(d) { return d.name.substring(0, d.r / 3); });
#+END_SRC

*** View Modes
The different layout modes are switched using =change_mode=, which
takes a mode string as a single argument.  Depending on the mode,
different parameters are used for the layouts.  In the end, opacities
are adjusted according to the mode, and the force layout is restarted
with the changed parameters.

#+NAME: change_mode
#+BEGIN_SRC js :noweb tangle
  function change_mode(mode) {
      var pack_opacity, new_alpha, collab_opacity, link_strength, node_charge_mul;
    
      switch(mode) {
      case 'collaboration':
          <<collaboration-mode-parameters>>
          break;
      case 'category':
          <<classification-mode-parameters>>
          break;
      }
      d3.select("#pack_svg").attr("opacity", pack_opacity);
      container.selectAll(".link").attr("opacity", collab_opacity);
      container.selectAll(".node").filter(function(d) {return d.type == "author"}).attr("opacity", collab_opacity);
      /*force.charge(function(d) { return ((1-i) * node_charge(d))})*/

      force.charge(function(d) { return collab_charge(d) * node_charge_mul })
          .linkStrength(link_strength)
          .start()
          .alpha(new_alpha);
  }
#+END_SRC

**** Collaboration Graph
For the Collaboration Graph
- all paper nodes are attracted towards an individual point determined
  by [[set_collab_paper_targets]]
- the horizontal force towards this target is lower then the vertical
  force
- the classification layout is hidden
- link strength is reduced to allow better clustering with papers as
  centers


#+BEGIN_SRC js :noweb-ref collaboration-mode-parameters
  kx = 0.15;
  ky = 0.4;
  node_charge_mul = 1;
  new_alpha = 1;
  pack_opacity = 0;
  collab_opacity = 1;
  link_strength = 0.5;
  /* set the target coordinates for the papers*/
  nodes.forEach(function(node) {
      set_collab_paper_targets(node);
  });

#+END_SRC

The attractor positions of the papers are a virtual grid, where the
papers are ordered in x-direction by the first letter of the bibtex
key, and in y-direction by the year of publication.  The y positions
are compressed in a way that recent publications are spaced wider than
older publications.

#+NAME: set_collab_paper_targets
#+BEGIN_SRC js
  function set_collab_paper_targets(node) {
      if (node.type == "paper") {
          // node.y_target = (((2016 - node.year))*20) + 200;
          node.y_target = (Math.sqrt(2016 - node.year) * 100) + 200;
          xmin = "A".charCodeAt(0);
          xmax = "Z".charCodeAt(0);
          xnode = node.name.toUpperCase().charCodeAt(0);
          node.x_target = Math.max(((xnode - xmin) / (xmax - xmin)) * width, 1);
      }
  }
#+END_SRC

**** Classification Layout
For the classification layout
- attractor force is the same for x and y
- node charge and link strength are zeroed to allow exact paper
  positioning
- the authors and links are made invisible, because they just flood
  the layout
- the attraction point for the paper nodes are set to the circle
  packing layout positions using [[set_category_paper_targets]]

#+BEGIN_SRC js :noweb-ref classification-mode-parameters
  kx = 1;
  ky = 1;
  node_charge_mul = 0;
  new_alpha = 0.1;
  pack_opacity = 1;
  collab_opacity = 0;
  link_strength = 0;
  /* set the target coordinates for the papers*/
  nodes.forEach(function(node) {
      set_category_paper_targets(node);
  });
#+END_SRC

The attractor positions are simply the centers of the calculated classification layout:

#+NAME: set_category_paper_targets
#+BEGIN_SRC js
  function set_category_paper_targets(node) {
      if (node.pack_node) {
          node.x_target = node.pack_node.x;
          node.y_target = node.pack_node.y;
      }
  }
#+END_SRC

*** Controls
At the bottom of the screen, there is space for some user interface
controls.  This allows live customization of the layout.

The controls are created using d3.js.

**** Display of Publication Type Symbols
The symbols used to display the type of publication tend to crowd the
layout, that is why they can be switched on/off.

#+BEGIN_SRC js
  controls = d3.select("body")
      .append("div")
      .style({position: "fixed", top: "90%"});

  controls.append("label")
      .text("Display Type of Publication");

  controls.append("input")
      .attr("type", "checkbox")
      // .attr("name", "show_symbols")
      .on("click", toggle_symbols);

  function toggle_symbols() {
      if (this.checked)
          d3.selectAll(".pub_type").attr("visibility", "visible");
      else
          d3.selectAll(".pub_type").attr("visibility", "hidden");
  }
#+END_SRC

*** BibTex File Loading
A Drag handler on the SVG element reacts to dropping a file onto the
canvas.  This causes the file to be parsed as BibTex File (see
[[BibTex Parser]]).  Nodes are compared to the existing ones.  If any
change happened, the layout is updated.

[[https://github.com/d3/d3/wiki/Selections#on][API reference for ".on()"]]
[[https://www.nczonline.net/blog/2012/05/08/working-with-files-in-javascript-part-1/][Information about FileReader with Drag'n'Drop]]
[[https://www.nczonline.net/blog/2012/05/15/working-with-files-in-javascript-part-2/][Information about reading file contents]]

The drop handler starts the FileReader.
#+BEGIN_SRC js
  d3.select("svg")
      .on("dragover", function() {
          d3.event.preventDefault(); })
      .on("drop", function() {
          d3.event.preventDefault();
          var files=d3.event.dataTransfer.files;
          if (files.length == 1) {
              var f = files[0];
              console.log("Filename: " + f.name);
              console.log("Type: " + f.type);
              console.log("Size: " + f.size + " bytes");
              reader.readAsText(f);
          }
      });
#+END_SRC

A =FileReader= is instantiated to asynchronously load the data.
Further processing (see also [[parse_bibtex_file]]) is initiated from its =onload= handler.

#+BEGIN_SRC js
  var reader = new FileReader();
  reader.onload = function(event) {
      var contents = event.target.result;
      console.log("File loaded");
      var entries = parse_bibtex_file(contents);
      var result = analyze_bibtex_entries(entries);
      nodes = result.nodes;
      links = result.links;
  };

  reader.onerror = function(event) {
      console.error("Unable to read file (Code: " + event.target.error.code + ")");
  };
#+END_SRC

The main information extraction happens here.  From each entry, the
following information is used:
- BibTex key
- title
- author list
- year of publication

Iterating through all the nodes, link and node information is built,
and returned in a result object.

#+NAME: analyze_bibtex_file
#+BEGIN_SRC js
  function analyze_bibtex_file(entries) {
      var authors = {};
      var papers = {};
      entries.forEach(function(e) {
      });
      return {nodes: null, links: null};
  }
#+END_SRC

*** Application Initialization/Data Loading
Since we are using d3.js's json load function, everything that needs
to happen after loading must be clumsily put into the event handler to
that function.

This helper iterates through all the nodes in the =tree= data member
and creates links to the flat listed nodes.
#+NAME: connect_node
#+BEGIN_SRC js
  function connect_node(pnode) {
      if (pnode.children) pnode.children.forEach(connect_node);
      else {
          var fnode = nodes.find(function(d) {
              return d.name == pnode.name
          });
          if (fnode) {
              pnode.force_node = fnode;
              fnode.pack_node = pnode;
          }
      }
  }
#+END_SRC

After loading, the [[data-globals][data globals]] are actually assigned the correct
values.  [[make_layout]] is responsible for actually creating all
layouts.  Change the initial mode to collaboration, which starts the
actual layout.  Trigger generating all jdenticon icons.

#+NAME: json_loader
#+BEGIN_SRC js
  d3.json("graph.json", function(error, json) {
      if (error) throw error;

      nodes = json.nodes;
      links = json.links;
      tree = json.tree;

      connect_node(tree);

      make_layout();

      jdenticon.update(".jdenticon");

      change_mode('collaboration');

  });
#+END_SRC

*** BibTex Parser
BibTex files are parsed using [[https://github.com/pegjs/pegjs][PEG.js]].

Limitations:
 - no support for "@string" (if someone tells me how to handle state
   during parser execution, that would be quite easy to add)
 - when encountering variables, they are not substituted

This should not really matter, since the information in such fields is
not displayed anyways (yet).

[[http://artis.imag.fr/~Xavier.Decoret/resources/xdkbibtex/bibtex_summary.html][This page]] has very nice information about the BibTex Syntax.

This expression is used to
generate the parser:

#+BEGIN_EXAMPLE text
  start = bibtex

  _ "whitespace" = [ \t\n\r]*

  name = value:[a-zA-Z0-9_]+ { return value.join("").toLowerCase() }
  number = value:[0-9]+ { return parseInt(value.join(""),10) }
  month_const = "jan"/"feb"/"mar"/"apr"/"may"/"jun"/"jul"/"aug"/"sep"/"oct"/"nov"/"dec"

  non_brace = value: [^{}]+ { return value.join("") }
  non_quote_non_brace = value: [^{}"]+ { return value.join("") }

  braced_value = "{" values: (non_brace / braced_value)* "}" { return values.join("") }
  quoted_value = "\"" values: (non_quote_non_brace / braced_value)* "\"" { return values.join("") }

  //fallback: when encountering an unquoted or unbrace value, assume variable name, without doing substitutions
  value = braced_value / quoted_value / number / month_const / name

  key = value:[^,]+ { return value.join("") }

  field = name:name _ "=" _ value:value { return { name:name, value:value}}
  field_with_separator = _ field:field _ "," { return field }

  normal_entry = "@" type:name _ "{" _ key:key _ "," fields:(field_with_separator)* _ last_field:field? _ '}'
    { fields.push(last_field);
      var ret = {bibtype: type, key: key};
      fields.forEach(function(f) { if (!ret[f.name]) ret[f.name] = f.value});
    return ret; }

  string = "@STRING"i _ "{" _ f:field _ "}" {error("@string directive not supported")}

  preamble = "@PREAMBLE"i _ "{" value "}"

  comment_body = value:[^@]+ {return value.join("")}

  comment_entry = "@COMMENT"i _ comment:braced_value { return comment }

  comment = comment_entry / comment_body

  entry = string / preamble / comment / normal_entry

  bibtex = elements:(entry / comment)* { return elements.filter(function(e) {return typeof(e) == "object"})}
#+END_EXAMPLE

# The parser itself is generated by passing the grammar description to
# the library:

# #+BEGIN_SRC js :noweb yes
#   var bibtex_parser = PEG.buildParser(`
#     <<bibtex-peg-parser>>
#   `);
# #+END_SRC


Now we need to generate the necessary node and link data from the
parsed BibTex.  For debugging purposes, the parse tree is stored
globally.
#+NAME: parse_bibtex_file
 #+BEGIN_SRC js
  var parse_tree;

  function parse_bibtex_file(content) {
      parse_tree = bibtex_parser.parse(content);
  }
#+END_SRC

* Hacking
This file is used to generate code and documentation.  It requires
org-mode which is supplied by emacs.  To (re-)generate the code file,
open this document and evaluate =org-babel-tangle=.
* Plan :noexport:
** TODO get rid of the author's background rect instead of hiding it
** TODO rename [[collab_charge]]
** TODO see if replacing svg filter with something static improves performance
** TODO directly extract the data from bibtex files
that would also make all the id stuff in the json data superfluous
- parser seems to work, now it needs to be incorportated:
- need file reader
- need the traversal that generates the links and nodes

** TODO re-implement classification layout without actually using the targets as attractors
blend the current attractor position with the classification target
position instead.  This way, no actual simulation has to be done when
switching modes
** TODO rename category -> classification
** TODO remove hardcoding 2016, substitute for current year
** TODO switch to radial cluster for classification layout
** TODO fix initial positioning in [[force-init]]
** TODO rename icon_size -> node_size
** TODO make glow radial
